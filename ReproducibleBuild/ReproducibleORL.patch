--- 1/ORL.Mod.txt
+++ 2/ORL.Mod.txt
@@ -97,6 +97,7 @@
         INC(size, DescSize);
         IF AllocPtr + size < limit THEN (*allocate*)
           p := AllocPtr; mod := SYSTEM.VAL(Module, p);
+          n := 0; FOR i := 0 TO DescSize DIV 4 - 1 DO SYSTEM.PUT(p + i * 4, n) END;
           AllocPtr := (p + size + 3) DIV 4 * 4; mod.size := AllocPtr - p;
           IF root = NIL THEN mod.num := 1 ELSE mod.num := root.num + 1 END ;
           mod.next := root; root := mod
@@ -106,6 +107,7 @@
       IF res = noerr THEN (*read file*)
         INC(p, DescSize); (*allocate descriptor*)
         mod.name := name; mod.key := key; mod.refcnt := 0;
+        FOR i := 0 TO MnLength - 2 DO IF mod.name[i] = 0X THEN mod.name[i+1] := 0X END END;
         mod.data := p;  (*data*)
         SYSTEM.PUT(mod.num * 4 + MTOrg, p);  (*module table entry*)
         Files.ReadInt(R, n);
@@ -222,10 +224,10 @@
         END ;
         SYSTEM.GET(Start, x);
         SYSTEM.PUT(Start, 0E7H * 1000000H + (x DIV 4) - 1);  (*branch instruction to the initialization body of the top module*)
-        SYSTEM.PUT(Start + 12, Kernel.MemLim);  (*limit of available memory; typically overwritten by the boot loader*)
+        SYSTEM.PUT(Start + 12, 0);  (*limit of available memory; typically overwritten by the boot loader*)
         SYSTEM.PUT(Start + 16, AllocPtr - Start);  (*address of the end of the module space loaded*)
         SYSTEM.PUT(Start + 20, SYSTEM.VAL(INTEGER, root) - Start);  (*current root of the links of loaded modules*)
-        SYSTEM.PUT(Start + 24, Kernel.stackOrg);  (*current limit of the module area; typically overwritten by the boot loader*)
+        SYSTEM.PUT(Start + 24, 0);  (*current limit of the module area; typically overwritten by the boot loader*)
         SYSTEM.PUT(Start + 252, 12345678H);  (*fingerprint*)
         MakeFileName(name, S.s, ".bin"); F := Files.New(name); Files.Set(R, F, 0); i := Start;
         WHILE i < AllocPtr DO SYSTEM.GET(i, x); Files.WriteInt(R, x); INC(i, 4) END ;
@@ -260,6 +262,10 @@
         END ;
         IF i > 0 THEN
           WHILE i < Kernel.SectorLength DO buf[i] := 0; INC(i) END ;
+          Kernel.PutSector(secno*29, buf)
+        END;
+        WHILE secno < 63 DO INC(secno);
+          i := 0; WHILE i < Kernel.SectorLength DO buf[i] := 0; INC(i) END;
           Kernel.PutSector(secno*29, buf)
         END
       ELSE Texts.WriteString(W, " not found")
