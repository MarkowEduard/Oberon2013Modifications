--- Edit.Mod	2022-01-28 22:03:24.791966000 +0100
+++ Edit.Mod	2022-01-28 21:56:05.478840000 +0100
@@ -1,27 +1,20 @@
 MODULE Edit; (*JG 2.11.90 / NW 28.11.2015*)
+
   IMPORT Files, Fonts, Texts, Display, Viewers, Oberon, MenuViewers, TextFrames;
 
   CONST CR = 0DX; maxlen = 32;
     StandardMenu = "System.Close System.Copy System.Grow Edit.Search Edit.Store";
 
   VAR W: Texts.Writer;
-    time: LONGINT;
-    M: INTEGER;
+    time, M: INTEGER;
     pat: ARRAY maxlen OF CHAR;
     d: ARRAY 256 OF INTEGER;
 
-  PROCEDURE Max(i, j: LONGINT): LONGINT;
-    VAR m: LONGINT;
-  BEGIN IF i >= j THEN m := i ELSE m := j END ;
-    RETURN m
-  END Max;
-
   PROCEDURE Open*;
     VAR T: Texts.Text;
-    S: Texts.Scanner;
-    V: Viewers.Viewer;
-    X, Y: INTEGER;
-    beg, end, time: LONGINT;
+      S: Texts.Scanner;
+      V: Viewers.Viewer;
+      X, Y, beg, end, time: INTEGER;
   BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
     IF (S.class = Texts.Char) & (S.c = "^") OR (S.line # 0) THEN
       Oberon.GetSelection(T, beg, end, time);
@@ -42,7 +35,7 @@
       T: Texts.Text;
       S: Texts.Scanner;
       f: Files.File; R: Files.Rider;
-      beg, end, time, len: LONGINT;
+      beg, end, time, len: INTEGER;
 
     PROCEDURE Backup (VAR name: ARRAY OF CHAR);
       VAR res, i: INTEGER; bak: ARRAY 32 OF CHAR;
@@ -74,7 +67,7 @@
     VAR T: Texts.Text;
       F: TextFrames.Frame;
       v: Viewers.Viewer;
-      beg, end, time: LONGINT;
+      beg, end, time: INTEGER;
       fnt: Fonts.Font; col, voff: INTEGER;
   BEGIN Oberon.GetSelection(T, beg, end, time);
     IF time >= 0 THEN
@@ -85,10 +78,10 @@
         Texts.ChangeLooks(T, beg, end, {0,1,2}, fnt, col, voff)
       END
     END
-  END CopyLooks; 
+  END CopyLooks;
 
   PROCEDURE ChangeFont*;
-    VAR S: Texts.Scanner; T: Texts.Text; beg, end: LONGINT;
+    VAR S: Texts.Scanner; T: Texts.Text; beg, end: INTEGER;
   BEGIN
     Oberon.GetSelection(T, beg, end, time);
     IF time >= 0 THEN
@@ -102,8 +95,7 @@
   PROCEDURE ChangeColor*;
     VAR S: Texts.Scanner;
       T: Texts.Text;
-      col: INTEGER;
-      beg, end, time: LONGINT;
+      col, beg, end, time: INTEGER;
   BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
     IF S.class = Texts.Int THEN
       col := S.i; Oberon.GetSelection(T, beg, end, time);
@@ -115,7 +107,7 @@
     VAR S: Texts.Scanner;
       T: Texts.Text;
       voff: INTEGER; ch: CHAR;
-      beg, end, time: LONGINT;
+      beg, end, time: INTEGER;
   BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
     IF S.class = Texts.Int THEN
       voff := S.i; Oberon.GetSelection(T, beg, end, time);
@@ -123,12 +115,96 @@
     END
   END ChangeOffset;
 
+  PROCEDURE Recall*;
+    VAR Menu, Main: Display.Frame;
+      buf: Texts.Buffer;
+      V: Viewers.Viewer;
+      pos: INTEGER;
+      F: TextFrames.Frame;
+  BEGIN V := Oberon.FocusViewer;
+    IF (V # NIL) & (V IS MenuViewers.Viewer) THEN
+      Menu := V.dsc; Main := V.dsc.next;
+      IF Main IS TextFrames.Frame THEN
+        F := Main(TextFrames.Frame);
+        IF F.hasCar THEN
+          TextFrames.Recall(buf);
+          pos := F.carloc.pos + buf.len;
+          Texts.Insert(F.text, F.carloc.pos, buf);
+          TextFrames.SetCaret(F, pos)
+        END
+      ELSIF Menu IS TextFrames.Frame THEN
+        F := Menu(TextFrames.Frame);
+        IF F.hasCar THEN
+          TextFrames.Recall(buf);
+          pos := F.carloc.pos + buf.len;
+          Texts.Insert(F.text, F.carloc.pos, buf);
+          TextFrames.SetCaret(F, pos)
+        END
+      END
+    END
+  END Recall;
+
+  PROCEDURE ShowPos(F: TextFrames.Frame; pos: INTEGER);
+    VAR R: Texts.Reader; ch: CHAR; n: INTEGER;
+  BEGIN
+    IF (pos < F.org) OR (TextFrames.Pos(F, F.X + F.W, F.Y) < pos) THEN
+      IF 256 < pos THEN n := pos - 256 ELSE n := 0 END;
+      Texts.OpenReader(R, F.text, n);
+      REPEAT Texts.Read(R, ch);
+        IF ch = 0DX THEN n := Texts.Pos(R) - 1 END
+      UNTIL Texts.Pos(R) = pos;
+      TextFrames.Show(F, n)
+    END
+  END ShowPos;
+
+  PROCEDURE Locate*;
+    VAR F: TextFrames.Frame;
+      T: Texts.Text; S: Texts.Scanner; R: Texts.Reader;
+      V: Viewers.Viewer;
+      name: ARRAY 32 OF CHAR;
+      beg, end, time, pos, i, n, X, Y: INTEGER; ch: CHAR;
+  BEGIN
+    V := Oberon.FocusViewer;
+    IF (V.dsc # NIL) & (V.dsc.next IS TextFrames.Frame) THEN
+      Oberon.GetSelection(T, beg, end, time);
+      IF time >= 0 THEN
+        Texts.OpenScanner(S, T, beg);
+        REPEAT Texts.Scan(S) UNTIL (S.class >= Texts.Int); (*skip names*)
+        IF S.class = Texts.Int THEN pos := S.i;
+          IF S.nextCh = "@" THEN
+            Texts.Scan(S); Texts.Scan(S);
+            IF S.class = Texts.Name THEN i := 0;
+              WHILE S.s[i] # 0X DO name[i] := S.s[i]; INC(i) END;
+              name[i] := "."; name[i+1] := "M"; name[i+2] := "o"; name[i+3] := "d"; name[i+4] := 0X;
+              Texts.OpenScanner(S, V.dsc(TextFrames.Frame).text, 0);
+              Texts.Scan(S);
+              IF (S.class = Texts.Name) & (S.s # name) THEN
+                Oberon.AllocateUserViewer(V.X, X, Y);
+                V := MenuViewers.New(
+                  TextFrames.NewMenu(name, StandardMenu),
+                  TextFrames.NewText(TextFrames.Text(name), 0),
+                  TextFrames.menuH, X, Y)
+              END
+            END
+          END;
+          F := V.dsc.next(TextFrames.Frame);
+          TextFrames.RemoveSelection(F);
+          TextFrames.RemoveCaret(F);
+          Oberon.RemoveMarks(F.X, F.Y, F.W, F.H);
+          ShowPos(F, pos);
+          Oberon.PassFocus(V);
+          TextFrames.SetCaret(F, pos)
+        END
+      END
+    END
+  END Locate;
+
   PROCEDURE Search*;  (*uses global variables M, pat, d for Boyer-Moore search*)
-    VAR Text: TextFrames.Frame;
+    VAR F: TextFrames.Frame;
       V: Viewers.Viewer;
       R: Texts.Reader;
       T: Texts.Text;
-      pos, beg, end, prevTime, len: LONGINT; n, i, j: INTEGER;
+      pos, beg, end, prevTime, len, n, i, j: INTEGER; ch: CHAR;
       buf: ARRAY 32 OF CHAR;
 
     PROCEDURE Forward(n: INTEGER; VAR R: Texts.Reader; VAR buf: ARRAY OF CHAR);
@@ -141,7 +217,7 @@
   BEGIN V := Oberon.Par.vwr;
     IF Oberon.Par.frame # V.dsc THEN V := Oberon.FocusViewer END;
     IF (V.dsc # NIL) & (V.dsc.next IS TextFrames.Frame) THEN
-      Text := V.dsc.next(TextFrames.Frame);
+      F := V.dsc.next(TextFrames.Frame);
       prevTime := time; Oberon.GetSelection(T, beg, end, time);
       IF time > prevTime THEN
         Texts.OpenReader(R, T, beg);
@@ -153,10 +229,10 @@
         j := 0;
         WHILE j # M - 1 DO d[ORD(pat[j])] := M - 1 - j; INC(j) END
       END;
-      IF Text.hasCar THEN pos := Text.carloc.pos ELSE pos := 0 END;
-      len := Text.text.len;
-      Texts.OpenReader(R, Text.text, pos);
-      Forward(M, R, buf); pos := pos + M;
+      IF F.hasCar THEN pos := F.carloc.pos ELSE pos := 0 END;
+      len := F.text.len;
+      Texts.OpenReader(R, F.text, pos);
+      Forward(M, R, buf); INC(pos, M);
       j := M;
       REPEAT DEC(j) UNTIL (j < 0) OR (buf[j] # pat[j]);
       WHILE (j >= 0) & (pos < len) DO
@@ -164,69 +240,14 @@
         REPEAT DEC(j) UNTIL (j < 0) OR (buf[j] # pat[j])
       END ;
       IF j < 0 THEN
-        TextFrames.RemoveSelection(Text); TextFrames.RemoveCaret(Text);
-        Oberon.RemoveMarks(Text.X, Text.Y, Text.W, Text.H);
-        TextFrames.Show(Text, pos - 300); Oberon.PassFocus(V);
-        TextFrames.SetCaret(Text, pos)
+        TextFrames.RemoveSelection(F); TextFrames.RemoveCaret(F);
+        Oberon.RemoveMarks(F.X, F.Y, F.W, F.H);
+        ShowPos(F, pos);
+        Oberon.PassFocus(V);
+        TextFrames.SetCaret(F, pos)
       END
     END
   END Search;
 
-  PROCEDURE Locate*;
-    VAR Text: TextFrames.Frame;
-      T: Texts.Text; S: Texts.Scanner;
-      V: Viewers.Viewer;
-      beg, end, time: LONGINT;
-  BEGIN
-    V := Oberon.FocusViewer;
-    IF (V.dsc # NIL) & (V.dsc.next IS TextFrames.Frame) THEN
-      Text := V.dsc.next(TextFrames.Frame);
-      Oberon.GetSelection(T, beg, end, time);
-      IF time >= 0 THEN
-        Texts.OpenScanner(S, T, beg);
-        REPEAT Texts.Scan(S) UNTIL (S.class >= Texts.Int); (*skip names*)
-        IF S.class = Texts.Int THEN
-          TextFrames.RemoveSelection(Text);
-          TextFrames.RemoveCaret(Text);
-          Oberon.RemoveMarks(Text.X, Text.Y, Text.W, Text.H);
-          TextFrames.Show(Text, Max(0, S.i - 200));
-          Oberon.PassFocus(V);
-          TextFrames.SetCaret(Text, S.i)
-        END
-      END
-    END
-  END Locate;
-
-  PROCEDURE Recall*;
-    VAR Menu, Main: Display.Frame;
-      buf: Texts.Buffer;
-      V: Viewers.Viewer;
-      pos: LONGINT;
-      M: TextFrames.Frame;
-  BEGIN V := Oberon.FocusViewer;
-    IF (V # NIL) & (V IS MenuViewers.Viewer) THEN
-      Menu := V.dsc; Main := V.dsc.next;
-      IF Main IS TextFrames.Frame THEN
-        M := Main(TextFrames.Frame);
-        IF M.hasCar THEN
-          TextFrames.Recall(buf);
-          pos := M.carloc.pos + buf.len;
-          Texts.Insert(M.text, M.carloc.pos, buf);
-          TextFrames.SetCaret(M, pos)
-        END
-      ELSIF Menu IS TextFrames.Frame THEN
-        M := Menu(TextFrames.Frame);
-        IF M.hasCar THEN
-          TextFrames.Recall(buf);
-          pos := M.carloc.pos + buf.len;
-          Texts.Insert(M.text, M.carloc.pos, buf);
-          TextFrames.SetCaret(M, pos)
-        END
-      END
-    END
-  END Recall;
-
 BEGIN Texts.OpenWriter(W)
-END Edit.
-
-
+END Edit.
\ No newline at end of file
