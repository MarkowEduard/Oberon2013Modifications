MODULE Edit; (*JG 2.11.90 / NW 28.11.2015*)  IMPORT Files, Fonts, Texts, Display, Viewers, Oberon, MenuViewers, TextFrames;  CONST CR = 0DX; maxlen = 32;    StandardMenu = "System.Close System.Copy System.Grow Edit.Search Edit.Store";  VAR W: Texts.Writer;    time, M: INTEGER;    pat: ARRAY maxlen OF CHAR;    d: ARRAY 256 OF INTEGER;  PROCEDURE Open*;    VAR T: Texts.Text;      S: Texts.Scanner;      V: Viewers.Viewer;      X, Y, beg, end, time: INTEGER;  BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);    IF (S.class = Texts.Char) & (S.c = "^") OR (S.line # 0) THEN      Oberon.GetSelection(T, beg, end, time);      IF time >= 0 THEN Texts.OpenScanner(S, T, beg); Texts.Scan(S) END    END;    IF S.class = Texts.Name THEN      Oberon.AllocateUserViewer(Oberon.Par.vwr.X, X, Y);      V := MenuViewers.New(        TextFrames.NewMenu(S.s, StandardMenu),        TextFrames.NewText(TextFrames.Text(S.s), 0),        TextFrames.menuH, X, Y)    END  END Open;  PROCEDURE Store*;    VAR V: Viewers.Viewer;      Text: TextFrames.Frame;      T: Texts.Text;      S: Texts.Scanner;      f: Files.File; R: Files.Rider;      beg, end, time, len: INTEGER;    PROCEDURE Backup (VAR name: ARRAY OF CHAR);      VAR res, i: INTEGER; bak: ARRAY 32 OF CHAR;    BEGIN i := 0;      WHILE name[i] # 0X DO bak[i] := name[i]; INC(i) END;      bak[i] := "."; bak[i+1] := "B"; bak[i+2] := "a"; bak[i+3] := "k"; bak[i+4] := 0X;      Files.Rename(name, bak, res)    END Backup;  BEGIN Texts.WriteString(W, "Edit.Store ");    IF Oberon.Par.frame = Oberon.Par.vwr.dsc THEN      V := Oberon.Par.vwr; Texts.OpenScanner(S, V.dsc(TextFrames.Frame).text, 0)    ELSE V := Oberon.MarkedViewer(); Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos)    END;    Texts.Scan(S);    IF (S.class = Texts.Char) & (S.c = "^") THEN      Oberon.GetSelection(T, beg, end, time);      IF time >= 0 THEN Texts.OpenScanner(S, T, beg); Texts.Scan(S) END    END;    IF (S.class = Texts.Name) & (V.dsc # NIL) & (V.dsc.next IS TextFrames.Frame) THEN      Text := V.dsc.next(TextFrames.Frame);      Texts.WriteString(W, S.s); Texts.WriteInt(W, Text.text.len, 8);      Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);      Backup(S.s); Texts.Close(Text.text, S.s)    END  END Store;  PROCEDURE CopyLooks*;    VAR T: Texts.Text;      F: TextFrames.Frame;      v: Viewers.Viewer;      beg, end, time: INTEGER;      fnt: Fonts.Font; col, voff: INTEGER;  BEGIN Oberon.GetSelection(T, beg, end, time);    IF time >= 0 THEN      v := Oberon.FocusViewer;      IF (v # NIL) & (v.dsc # NIL) & (v.dsc.next IS TextFrames.Frame) THEN        F := v.dsc.next(TextFrames.Frame);        Texts.Attributes(F.text, F.carloc.pos, fnt, col, voff);        Texts.ChangeLooks(T, beg, end, {0,1,2}, fnt, col, voff)      END    END  END CopyLooks;  PROCEDURE ChangeFont*;    VAR S: Texts.Scanner; T: Texts.Text; beg, end: INTEGER;  BEGIN    Oberon.GetSelection(T, beg, end, time);    IF time >= 0 THEN      Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);      IF S.class = Texts.Name THEN        Texts.ChangeLooks(T, beg, end, {0}, Fonts.This(S.s), 0, 0)      END    END  END ChangeFont;  PROCEDURE ChangeColor*;    VAR S: Texts.Scanner;      T: Texts.Text;      col, beg, end, time: INTEGER;  BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);    IF S.class = Texts.Int THEN      col := S.i; Oberon.GetSelection(T, beg, end, time);      IF time >= 0 THEN Texts.ChangeLooks(T, beg, end, {1}, NIL, col, 0) END    END  END ChangeColor;  PROCEDURE ChangeOffset*;    VAR S: Texts.Scanner;      T: Texts.Text;      voff: INTEGER; ch: CHAR;      beg, end, time: INTEGER;  BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);    IF S.class = Texts.Int THEN      voff := S.i; Oberon.GetSelection(T, beg, end, time);      IF time >= 0 THEN Texts.ChangeLooks(T, beg, end, {2}, NIL, voff, 0) END    END  END ChangeOffset;  PROCEDURE Recall*;    VAR Menu, Main: Display.Frame;      buf: Texts.Buffer;      V: Viewers.Viewer;      pos: INTEGER;      F: TextFrames.Frame;  BEGIN V := Oberon.FocusViewer;    IF (V # NIL) & (V IS MenuViewers.Viewer) THEN      Menu := V.dsc; Main := V.dsc.next;      IF Main IS TextFrames.Frame THEN        F := Main(TextFrames.Frame);        IF F.hasCar THEN          TextFrames.Recall(buf);          pos := F.carloc.pos + buf.len;          Texts.Insert(F.text, F.carloc.pos, buf);          TextFrames.SetCaret(F, pos)        END      ELSIF Menu IS TextFrames.Frame THEN        F := Menu(TextFrames.Frame);        IF F.hasCar THEN          TextFrames.Recall(buf);          pos := F.carloc.pos + buf.len;          Texts.Insert(F.text, F.carloc.pos, buf);          TextFrames.SetCaret(F, pos)        END      END    END  END Recall;  PROCEDURE ShowPos(F: TextFrames.Frame; pos: INTEGER);    VAR R: Texts.Reader; ch: CHAR; n: INTEGER;  BEGIN    IF (pos < F.org) OR (TextFrames.Pos(F, F.X + F.W, F.Y) < pos) THEN      IF 256 < pos THEN n := pos - 256 ELSE n := 0 END;      Texts.OpenReader(R, F.text, n);      REPEAT Texts.Read(R, ch);        IF ch = 0DX THEN n := Texts.Pos(R) - 1 END      UNTIL Texts.Pos(R) = pos;      TextFrames.Show(F, n)    END  END ShowPos;  PROCEDURE Locate*;    VAR F: TextFrames.Frame;      T: Texts.Text; S: Texts.Scanner; R: Texts.Reader;      V: Viewers.Viewer;      name: ARRAY 32 OF CHAR;      beg, end, time, pos, i, n, X, Y: INTEGER; ch: CHAR;  BEGIN    V := Oberon.FocusViewer;    IF (V.dsc # NIL) & (V.dsc.next IS TextFrames.Frame) THEN      Oberon.GetSelection(T, beg, end, time);      IF time >= 0 THEN        Texts.OpenScanner(S, T, beg);        REPEAT Texts.Scan(S) UNTIL (S.class >= Texts.Int); (*skip names*)        IF S.class = Texts.Int THEN pos := S.i;          IF S.nextCh = "@" THEN            Texts.Scan(S); Texts.Scan(S);            IF S.class = Texts.Name THEN i := 0;              WHILE S.s[i] # 0X DO name[i] := S.s[i]; INC(i) END;              name[i] := "."; name[i+1] := "M"; name[i+2] := "o"; name[i+3] := "d"; name[i+4] := 0X;              Texts.OpenScanner(S, V.dsc(TextFrames.Frame).text, 0);              Texts.Scan(S);              IF (S.class = Texts.Name) & (S.s # name) THEN                Oberon.AllocateUserViewer(V.X, X, Y);                V := MenuViewers.New(                  TextFrames.NewMenu(name, StandardMenu),                  TextFrames.NewText(TextFrames.Text(name), 0),                  TextFrames.menuH, X, Y)              END            END          END;          F := V.dsc.next(TextFrames.Frame);          TextFrames.RemoveSelection(F);          TextFrames.RemoveCaret(F);          Oberon.RemoveMarks(F.X, F.Y, F.W, F.H);          ShowPos(F, pos);          Oberon.PassFocus(V);          TextFrames.SetCaret(F, pos)        END      END    END  END Locate;  PROCEDURE Search*;  (*uses global variables M, pat, d for Boyer-Moore search*)    VAR F: TextFrames.Frame;      V: Viewers.Viewer;      R: Texts.Reader;      T: Texts.Text;      pos, beg, end, prevTime, len, n, i, j: INTEGER; ch: CHAR;      buf: ARRAY 32 OF CHAR;    PROCEDURE Forward(n: INTEGER; VAR R: Texts.Reader; VAR buf: ARRAY OF CHAR);      VAR m: INTEGER; j: INTEGER;    BEGIN m := M - n; j := 0;      WHILE j # m DO buf[j] := buf[n + j]; INC(j) END;      WHILE j # M DO Texts.Read(R, buf[j]); INC(j) END    END Forward;  BEGIN V := Oberon.Par.vwr;    IF Oberon.Par.frame # V.dsc THEN V := Oberon.FocusViewer END;    IF (V.dsc # NIL) & (V.dsc.next IS TextFrames.Frame) THEN      F := V.dsc.next(TextFrames.Frame);      prevTime := time; Oberon.GetSelection(T, beg, end, time);      IF time > prevTime THEN        Texts.OpenReader(R, T, beg);        i := 0; pos := beg;        REPEAT Texts.Read(R, pat[i]); INC(i); INC(pos)        UNTIL (i = maxlen) OR (pos = end);        M := i; j := 0;        WHILE j # 256 DO d[j] := M; INC(j) END;        j := 0;        WHILE j # M - 1 DO d[ORD(pat[j])] := M - 1 - j; INC(j) END      END;      IF F.hasCar THEN pos := F.carloc.pos ELSE pos := 0 END;      len := F.text.len;      Texts.OpenReader(R, F.text, pos);      Forward(M, R, buf); INC(pos, M);      j := M;      REPEAT DEC(j) UNTIL (j < 0) OR (buf[j] # pat[j]);      WHILE (j >= 0) & (pos < len) DO        n := d[ORD(buf[M-1])]; Forward(n, R, buf); INC(pos, n); j := M;        REPEAT DEC(j) UNTIL (j < 0) OR (buf[j] # pat[j])      END ;      IF j < 0 THEN        TextFrames.RemoveSelection(F); TextFrames.RemoveCaret(F);        Oberon.RemoveMarks(F.X, F.Y, F.W, F.H);        ShowPos(F, pos);        Oberon.PassFocus(V);        TextFrames.SetCaret(F, pos)      END    END  END Search;BEGIN Texts.OpenWriter(W)END Edit.